# -*- coding: utf-8 -*-
"""Detector_de_expressao.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MaRN3T1QZQ5DSHhVXjB1FufqAuYCtol5

#Faculdade Uniasselvi
##Polo: Biguaçu
##Disciplina: Projeto II - Futuro dos Dados e Aplicação de Big Data (19375)
##Aluno: Fábio Ribeiro de Souza
##Título: Análise de sentimento em expressões faciais

#Etapa I

##Definição do tema:

O conjunto de dados (FER-2013 - Disponível em: https://www.kaggle.com/datasets/msambare/fer2013) consiste em um dataset de imagens com tamanho de 48x48 pixel, em escala de cinza, contendo imagens de faces de pessoas, categorizadas em sete categorias: Angry, Disgust, Fear, Happy, Sad, Surprise e Neutral. A base de dados esta dividida em dois conjuntos de dados, o de treinamento, com 28.709 imagens e o de teste, com 3.589 dados. Esse conjunto de dados é utilizado para estudar e desenvolver modelos de aprendizado de máquina, para detectar sentimentos a partir das expressões faciais.
Neste trabalho, será desenvolvido um modelo para detectar sentimentos a partir de expressões faciais utilizando uma base de dados maior do que a FER-2013 original. Trata-se da base denominada Extended and Augmented Google FER Starter (disponível em: https://www.kaggle.com/code/prajwalsood/extended-and-augmented-google-fer-starter/data). Esta base tem as mesmas características da base original (imagems de rostos, em tons de cinza, com tamanho de 48x48pixel), contudo apresenta 40.811 imagens e uma categoria a mais chamada Contempt.
Este conjunto de dados esta dividido em dados de treino (32.645 imagens) e dados de teste (8.166 imagens).
Para desenvolver este trabalho, primeiro será analizado o conjunto de dados para observarmos como estão distribuídos e quais suas características. Posteriormente será testado um modelo baseado em uma rede de aprendizado profundo (deep learning), para detectar as emoções expressas nas imagens e terá sua performance avaliada pela métrica da acurácia e função de custo. Para verificar como impacta a profundidade da rede neste dataset, será desenvolvido um segundo modelo, baseado em uma arquitetura de rede mais profunda, para comparar os resultados obtidos entre os dois modelos.

##Objetivo:
Esse projeto tem como objetivo detectar sentimentos a partir de imagens de rostos de pessoas.

##Especificação técnica:
A base de dados utilizada é a *Extended and Augmented Google FER*, disponível em: https://www.kaggle.com/datasets/prajwalsood/google-fer-image-format. Esta base de dados é composta por imagens de rosto de pessoas, com tamanho de 48x48 pixel, no formato *.jpg. A base está organizada em dois conjuntos, um para realizar o treinamento do modelo e outro para validar o modelo. Os dados vêm salvos em oito diretorios, denominados: Anger, Contempt, Disgust, Fear, Happiness, Neutral, Sadness e Suprise. Após salvar a base de dados em uma pasta do Google Drive, os diretórios foram renomeados, traduzindo para o português : Raiva, Desprezo, Nojo, Medo, Felicidade, Neutro, Tristeza e Surpresa.
Posteriormente foi retirado 10 imagens aleatórias de cada classe do diretório de validação e salvo em um diretório chamado test, para ser utilizado no final do trabalho para verificar a performance do modelo com dados inéditos.
Os modelos utilizarão uma rede CNN - Convolutional Neural Network, com camadas de convolução,  camadas de pooling e uma rede densa. A função de ativação das camadas de convolução será a função 'relu'.Para a camada densa, será utilizado a função 'relu' e 'softmax' na ultima camada.
Para calcular a função de custo, será utilizado o método de entropia cruzada. A acurácia do modelo será avaliado pelo método da acurácia.

#Etapa II

##Importação das bibliotecas
"""

#Importação das bibliotecas
import numpy as np #Usado para avaliar o modelo (Matrix de confuzão)
import pandas as pd #Analise dos dados. Usado para gerar dataframe a partir do dataset
import os #Manipulação do sistema de arquivos
import tensorflow as tf #Biblioteca de aprendizado de máquina
from keras.preprocessing.image import ImageDataGenerator, load_img #Usado para gerar os lotes de tensores das imagens e aumento dos dados (técnica de data augmentation).
from keras.layers import Conv2D, Dense, BatchNormalization, Activation, Dropout, MaxPooling2D, Flatten #Camadas da rede
from keras import regularizers # Usado para aplicar penalidades nos parâmetros da camada ou na atividade da camada durante a otimização.
from keras.callbacks import ModelCheckpoint, CSVLogger, TensorBoard, EarlyStopping, ReduceLROnPlateau #Usado para criar as funções de Callbacks
import datetime #Usado para trabalhar com datas e horas. Utilizado no registro dos logs durante o treinamento
import matplotlib.pyplot as plt #Usado para imprimir as figuras e labels para avaliação do dataset.
from keras.utils.vis_utils import plot_model
from tensorflow.keras.optimizers import Adam, RMSprop, SGD

#Verificação para saber se o ambiente está usando a GPU para processar
tf.test.gpu_device_name()

"""##Importando o Dataset"""

#Montar a partição do google drive
from google.colab import drive
drive.mount('/content/drive')

#Carregando a base de dados que está salva no google drive.
train_dir = '/content/drive/MyDrive/Projeto_II/Detector_de_expressoes/train' #Carregando os dados de treinamento
val_dir = '/content/drive/MyDrive/Projeto_II/Detector_de_expressoes/val' #Carregando os dados de validação
test_dir = '/content/drive/MyDrive/Projeto_II/Detector_de_expressoes/test' #Carregando os dados de validação

#Verificando o nome das pastas carregadas
train_emotions = sorted(os.listdir(train_dir))
val_emotions = sorted(os.listdir(val_dir))
print(train_emotions)
print(val_emotions)

"""##Explorando o Dataset"""

#Contando o tamanho do dataset.
def count_exp(path, set_):
    dict_ = {}
    for expression in os.listdir(path):
        dir_ = path + '/' + expression
        dict_[expression] = len(os.listdir(dir_))
    df = pd.DataFrame(dict_, index=[set_])
    return df
train_count = count_exp(train_dir, 'Treino')
val_count = count_exp(val_dir, 'Validação')
print(train_count)
print(val_count)

#Analizando a distribuição dos dados de treinamento.
train_count.transpose().plot(kind='bar', color='red')

"""Observação:

*   A feature "Felicidade" é significativamente maior que as demais
*   As features "Desprezo" e "Nojo" são as menores, provavelmente por ser fruto da classe "Disgust" original.


"""

#Analisando a distribuição dos dados de teste.
val_count.transpose().plot(kind='bar', color='green')

"""Observação:

*   A distribuição das classes no dataset de validação, segue a mesma proporção de distribuição, do set de treinamento.
"""

#Imprimindo um exemplo de cada diretório do dataset de treinamento.
plt.figure(figsize=(14,22))
i = 1
for expression in os.listdir(train_dir):
    img = load_img((train_dir + '/' +expression +'/'+ os.listdir(train_dir + '/' + expression)[8]))
    plt.subplot(1,8,i)
    plt.imshow(img)
    plt.title(expression)
    plt.axis('off')
    i += 1
plt.show()

#Impriminto 8 exemplos de imagens do dataset de treinamento com a label = Felicidade
picture_size = 48
expression = 'FELICIDADE'

plt.figure(figsize= (12,12))
for i in range(1, 9, 1):
    plt.subplot(4,4,i)
    img = load_img(train_dir +'/' +expression+ '/'+ os.listdir(train_dir + '/' + expression)[i], target_size=(picture_size, picture_size))
    plt.imshow(img)   
plt.show()

#Impriminto 8 exemplos de imagens do dataset de treinamento com a label = Nojo
expression = 'NOJO'

plt.figure(figsize= (12,12))
for i in range(1, 9, 1):
    plt.subplot(4,4,i)
    img = load_img(train_dir +'/' +expression+ '/'+ os.listdir(train_dir + '/' + expression)[i], target_size=(picture_size, picture_size))
    plt.imshow(img)   
plt.show()

"""##Criando os datasets de treino e validação

Estrutura de dados salva no google drive é semelhante a essa:
![image.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA0kAAAGcCAIAAACDd3yiAAAgAElEQVR4nOzdd7xU5Z0/8Od5Tpkz5V5KUDeaYrqKiGCPUSmKojHG1RRNggkKEqxb8nL3l4BSLNHddVezab4SddWom+imrAWDjWIsqAEsgAoW7MBtU05/fn98Mk9mUYbi5c6dmc/7D16XuXPPPHPO+Z7zfeqRWmtBRNQMpJRSSiGEbdtRFAkhlFJaa17H+h32KvY2ETUXu9EFICLaDnEc41/XddM0RW7HFKR/cX8SNTXV6AIQEW0ry7KUUlEUua6bJIlSKk1TZHtERATM7YioaSRJ0tfXl8lk0jRF25Lv+47jNLpcRESDCHM7ImoalmV1dHQIIcrlslJKCJHL5ZIkaXS5iIgGEeZ2RNQ0kiSpVCpxHBcKBa217/uNLhER0aAjOb+MiJqF4zhRFCVJkqYpxt6FYei6bqPL1WqklJwnS9S82G5HRE0D0yYsy9psUkWjy0VENIiw3Y6ImgbbkwYG9zNRU2O7HREREVHrYG5HRERE1DqY2xERERG1DuZ2RERERK2DuR0RERFR62BuR0RERNQ6mNsRERERtQ7mdkREW5GmqRDCLJKcpilWUTbrg5qnn+GdW1K7BfMDFxklov7F3I6IaCuwhG+5XBZChGGolLJtu1wu4/UgCDzP01qnaaqUqpPemd9qreM4jqJIKcX1gYmof/G5FETUNBr4vIQoihzHSZLEsixRbbGTUiZJgvwsiiIppW3b9bcThqHjOPhb5ILY8gB8hW3H51IQNTW22xERbZMkSYIgEEKkaer7PvKeJEmklEEQOI6DxA7dtVuCRBCpoUkQB6L0RNQ2mNsREW0FUrc0TXO5HDK8TCYjhAjD0HVdIYRSCt2sSZLUabrTWtfmf1t9PxHRDmBuR0S0FZlMplKpOI4TRVGaptlsVimFV4QQPT09juPIqq1uLU1TdOxmMhmleBEmon7GywoR0VYkSeK6rtbacRzHccIwjOPYtm0ppe/7nZ2dcRzHcSylRAPelraDMXbI7UqlEl5BPy8RUX9hbkdEtBVa6+XLlyulXNe1LCtTJaU84YQTSqWSbdu2bZs5sPW3hk7YV199dePGjUIIdO8SEfUX5nZERFuBHlhMhkUvqulXXbx4cUdHx6JFi/C2IAiUUljHzqR6Znm8JEm01lEUnXPOOeeff76omXhhfkiSJAzD2hcrlQryRbxuFskjInpfzO2IiLZCKeX7vlLql7/8JYbcaa3DMNRa33jjjVLKv//7v1+3bl0YhplMpq+vz7IsvA2rHGOhEyGEZVlSylKphBwREymSJInjGJliFEWWZbmuWywWoyhCC182m0Vaif9y4Soiqo+5HRHRVkRRNGTIkCRJstlsHMdoh0Nz2imnnHLrrbc++eSTN954o+d5lUqlo6MD6Zdt22ZpYsuyLMtK0zSKoqFDhzqOo5TCVAxkeCZjww+FQsFxnDiOsWCyqC62gk01Yh8QUdNgbkdEtBVot7MsCwudILvK5XJSSsdxTjnllLPPPnvx4sUYeIckbPbs2Zg267qulPKyyy5L01RK+fLLL++7774//vGPFyxYMHz48Pnz52MVlZ6enmOOOSafzyul0Lz38MMP27bteR6mbmAqLjbS6P1BRIMaczsioq2wLCsIArSoeZ4nhPB9H+PnpJSVSuULX/jCokWLHnnkEaVUX1/fhAkT/v3f/x19qVrrTCZz8cUXz507Fw+xwHbMuD0hxNKlS3fZZZcHHnjAPNxi+PDh48aNW7p0qdbaqkqSpP7zaomIBHM7IqKtiuM4l8u5rhtFURAEURR5noeHw4Zh2NHR8clPflJrncvlLMu66667Hnzwweuvv37Tpk0YmXf33XdLKR999NFyufzJT35y5cqVM2bMmDx58saNG2fPnt3X13fbbbd94hOfePHFFzHxoru7e9q0aZZl3XfffZi0YZ6BwfXwiGireJkgItoKTIbwfR9Ln+BFNLC5rpskCRarW7t2rRDi1FNP1Vp//etfx7TWSqVyxBFHTJ8+XWtdLpcty+ru7o6iKEkS3/eFEJlM5tprr33hhRf22GMPzL3IZrNnnXXWfvvth+X00jQtl8taa9d1lVL1n2lGRMTcjohoK9Bahl7RKIqQb+FXaZomSbJhwwYhxMc//vE4jjOZDOZMdHZ2dnV1nXrqqZ7n/fznP3/rrbd6e3uFEB0dHZlMRmstpcSqyNgO0sSnnnpKSjly5Minn376zTff7OnpUUphbB8m3vIZZURUH3M7IqKtQJuZ6RLVWqP9zDyIAlkasjohxBVXXIEpFMOHD7/33nvRM4uuVTyONggC27ZzuRzWRunq6ho/frzneblc7pBDDhFChGEopQzDMJvNCiHQwoc/b+SOIKJmwNyOiGgrtNZBEGDVOtNshoVLkOE98sgjEydO/MQnPuG67g033DBr1iwhxOjRo1999VVMwvjKV76Cx9FaluV5nmVZvu9j3F5fX9//+3//75FHHkmS5Jvf/KbWOkmSNWvWjB492rbtUqmktfY8D9MsHMdBnkdEtCXM7YiItkJKmcvl0GaGlU2EEMjqbNu+7bbbrr322i984QsjRowIguCxxx6bMGFCV1fXk08+uccee0RR1N3dHQRBb2+v53la62KxiHXvkKW9/fbbjz766CWXXBJF0XXXXdfX16eUWr9+/TPPPJMkSUdHBz4OqaHv+5ioS0S0JcztiIi2QmtdqVREdWFhrEWCB8hed911U6dOPeigg772ta9hyoVSauHChatXr8aTJ958882JEyf+9re/zWQy5XI5DMOhQ4dimN2wYcPwhLEgCBYuXFipVGzbLhQKv/71rydMmCCEcBwHi9ulaYoF9jzP4zIoRFQfx+QSEW2dlHLo0KFnnHHGzJkzMStWCIFkK0mSq6+++jOf+YwQolAoHHDAAbZtH3bYYXjyBHIy/AqzKDZu3Gjb9l133TVkyJB58+adc845xx577LXXXpvL5Wo/Ee2CeGqFqK6rhyfSciUUIqqDFwgioq1ALtXd3Y0BcI7j5PN5/Or0008vl8uHH364bdtBEKRpOnXq1Ouvv15rjWdUCCEWLVp0++23L1269O677xZCZDKZiy666MADD0Srnm3bP/jBD77zne9ks1nLsmzbnjhx4uuvv37hhRc++OCDr776qhAiCAIsfYLNNmxHEFEzkHzsNBE1CzzmAfNSB/ijsfSJmRJbLpcLhQKa0MrlsmlyM1NihRBI7MzjX7EF/FypVDABNgxDrIGCztlsNhuGoW3bUko8Z0xrHYYhFtXD484G4Ls3cD8T0QfH3I6ImkYDcw48gsLzPDObwbwiqlkX/sWqKOg8RZZW+yfI/NI0RVtgkiTmv3EcmzY58wZ8WfMsMvMnO/XLMrcjamrM7YioaTDnGBjcz0RNjePtiIiIiFoHczsiIiKi1sHcjoiIiKh1MLcjIiIiah3M7YiIiIhaB3M7IiIiotbB3I6IiIiodTC3IyIiImodzO2IiIiIWgdzOyIiIqLWwdyOiIiIqHUwtyMiIiJqHcztiIiIiFoHczsiIiKi1sHcjoiIiKh1MLcjoqahlBJCxHEshEiSRAihtcYPg0oYhubnJEm01qJa4KaglNJaR1EkqntbNFX5idqc3egCEBFtqzRN4zh2HEdrbVlWFEVKKcuykDwNHq7rpmkqhMC/UspKpZLNZgdbObdESqm1dl3X933HcYQQaZoisSaiwY+5HRE1Ddd1LctCS1Kapq7rIr2TUja6aP9HFEUokm3bQohisVgoFEqlUj6fb3TRtkmSJEqpMAw9zxNCoORhGLqu2+iiEdHWyWapRxIRoT1Ja43MKUkSy7KEEIPtOpYkiW3bKF6lUvE8DwUebOXcEs/zgiAIw9CyLCklvs5gS6CJaEvYbkdETSOTydRmGEj1GlieLZFSmjTUdd3a4XfNIggC9MaiWVRK6fs+mvGIaJAbpFdGIqL3Mg11EARBJpNpYHm2JEkSKSVmJODfRpdou5kBdr7vu66rlNps5xPRoMWxsUTUNJBbVCoVIYTv+0jsgiBocLHew7IsMz0W0jTFtNOmYBK73t5ez/MwGZmJHVGzYLsdETWTOI4xQUG8pxlvsMEyIkOHDi2VSmmaDuaivtd793MUReilJaJBjrkdEdHOkqYpJlUIITgXgYgGBvtkiYiIiFoHczsiIiKi1sHcjoiIiKh1MLcjIiIiah3M7YiIiIhaB3M7IiIiotbB3I6IiIiodTC3IyIiImodzO2IiIiIWgdzOyIiIqLWwdyOiIiIqHUwtyMiIiJqHcztiIiIiFoHczsiIiKi1sHcjoiIiKh1SK11o8tA7yNJEsuywjB0Xfe4445bsGBBo0tERNtKSimEUEqlaWqusZZlJUnS0HIR0TaxLEtrnabphAkT/vjHPyrVZA1hzO0GLyR2URS5rovDpLXGPYOIBjOtdRRFSimlFG4SQog4jm3bbnTRiGgr0jSVUpbL5Xw+L6UMgsB1XdyRG120bdVkqWj70FpbloUfstlskiRpmkZR1OhyEdHWSSlt27ZtW2utlEIDACKaiAY5tNLl83nf9y3Lwn+bKLETzO0GrSAIcCdwXbdSqeD0aq5zi6htIaUrFototKtUKsjwGl0uItomYRgKITzPS5JEStl0bSvM7QYpz/O6urqEELgfRFGktcbZRkSDnO/7QohCoeD7vud5uVwuDMOmG7JD1LYymUwcx0EQeJ5nWZbv+47jNLpQ24Hj7QapSqWSzWbRIJzJZNI0bXSJiGg7pGmKKEbTXblczuVyjS4UEW2dGdqOBnjMiGquulkzlbWtZLPZMAw9z3McB4N14jhudKGIaJug3S6fzyulpJRRFDGxI2oWiFkhBOYySimVUgjqZsHcbpBK0xRT6srlciaTQdWh0YUiom3iOA4G2CVJorV2HId1M6Jmkaap4zhpmmJ6bBiGWmvP8xpdru3APtnBDkkelsXiAihEzYXxS9S8mjd+2W5HRERE1DqY2xERERG1DuZ2RERERK2DuR0RERFR62BuR0RERNQ6mNsRERERtQ7mdkREREStg7kdERERUetgbkdERETUOpjbEREREbUO5nZERERErYO5HREREVHrYG5HRERE1DqY2xERERG1DuZ2RERERK2DuR0RERFR62BuR0RERNQ6mNsRERERtQ7mdkREREStg7kdERERUetgbkdERETUOpjbEREREbUO5nZERERErYO53SB177335vP5W265JY7jTCYjpfzlL385bNiwe++9N01TIUQcx0KIKIqEEEmSNLi4RFSD8UvUvFogfqXWutFloPc3dOjQKIoymUx3d/fw4cODIPB9HydTuVzOZDKWZVUqlUwmoxRzdKLBhfFL1LyaPX4HY5lICFEul7/3ve9JKbu6urTW3d3dURTNmTNHCBFFkW3blmUJIRzHUUqhDkFEgwTjl6h5tUD8st1u8NJao0LgOA6qC1prnFhSSiFEEASu60op4zi2bbvBxSWiGoxfoubV7PHLdrtBKkmScrn8r//6r0IIpdTw4cNnz54thHAcx7wBJ1aSJIPwxCJqZ4xfoubVAvHLdrvBy/d9z/M8zwuCQAihtdZam+ZfpRSahcMwdF23kQUlovdg/BI1r2aPX7bbDV6O4wRBcNVVVxUKhauuuipJkiAInCrUGNI0HZwnFlGbY/wSNa9mj1+22w1SSZKgWlAqlWbMmPHzn/8c83FQddBa45TSWkspoygybcVE1HCMX6Lm1QLx23a5nZQSAyFt28YASRywdtsPAwB7FXubqF8wfgcM45f6HeN3wAzGMYA7G7rM4zh2XTdNU5xbvIT1L+5P2kkYvwOA+5N2EsbvAJBStt14O8uylFJRFLmumySJUipN08G5Pg0RbYbxS9S8GL8Dpu1yuyRJ+vr6MplMmqaoK/i+Pwg7y4novRi/RM2L8Ttg2i63syyro6NDCFEul7EyYS6XG5zPgyOizTB+iZoX43fAtF1ulyRJpVKJ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dXUdfPDBP/3pTzFAVin1ne9859/+7d8wRsK27enTp1933XWYQS+EuPTSSy+88MLu7m7z+DJRXaqssePamdv1MzPkua+vT2uNtYvRkY/kDN32pVIJ5xkahz3P8zxv2bJlURT19vZ2d3dPmTKlu7v7uuuuO/zww0ulUl9fH7r/p06d+tRTT/35z3/GmZckCeb7oOpfKpXSNP3tb3/b09OTJMmyZcssy1q8ePH69euFEOZPuPYp0fuq7YoV1bl16IH90pe+NGnSJAy5w3tc1122bNk999wzfvz4ESNGLFiw4Pe///2dd94Zx3FXV1cURYsWLRJCLFq06M0338zn87gfZLNZ27YRiblcDm3qf/7zn6+55ppJkyahtR4thddcc03DdgRRC0GmValU0LyCmpVSCv1s+XweS0smSXLllVc+88wzt99+e3d3NwZBnXHGGd///vcfeugh27aff/75FStWzJ8/3/d93OKnTJmyYMGC3t7eNE1/8pOf3HLLLVLKhQsX3nPPPSNGjGjkV27gZ7ckpVSxWNRa40GQZpoqTiNRbTwzg+fMWYUBAWeccQYGAeCEe+CBBx5++GHLsrAqT5qmZ555ppQSnTXo2UG7XZqmaKs799xzjzrqKNd1lVKf+tSnZsyYUalUdt11VzzNDEO52ddDVN9mT720bbujo+OQQw5ZsmTJM888I6qjYxctWnTooYeedNJJcRyfdtppWusTTjgBwWjb9qhRo2bOnInsEK0F5XIZ1wSzRhLGyy5atOizn/3sT37yk46ODjTdXXvttcccc0xD9wFRi8Doumw2a6aiCyHiOMYYO0xedF33tddeu/fee2+55ZZTTjnFrEl+xRVXHH/88YsWLdJaF4vFZcuWvfLKK1haXGv9s5/9bNWqVR/5yEcwUA+5I1rsahe1GHjM7fpfoVDA0ylk9fniuLjjZoBX0MCGqTRYiT6Tyey99977778/zhj8OYZkoi3wlltuQV+t1nr9+vV4tFEURT09PYVCAZNqhRBf+MIXzBL2Q4cO7ejoiOP4hRdewHA9tBZgBCgRbaa2G8Ukduiv0VpPnjw5TdP7779fCKGUWr16NUZNfPzjH0csY3kUx3Heeuut448/PpfL/fSnP123bh2eb+G6ruu65mpg1jHu7e297777Jk+ejAnveJZgNpvdc889G7MXiFoLalBm5jvaU7LZLEbU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1nrWrFnHHntsb28vSoupGL/73e8OOuig559/PkmSpUuXCiEuvPDCcrlcu+tQwi3t534bb4dJar7vv/XWW4cddtiQIUPMkNuxY8dqrb/85S8LITBnPkkSzKXH4UHn+vnnn5/L5X7wgx8899xz69evl1Luvvvu48ePv+mmmzBt6l/+5V8w0xgNqgcccMCECRP+8Ic/YCb/VVddValUMJi6TjkxjQuDeU2brVLq17/+tZTywAMPtG377bffrn2QEYnmOb4Y04AflFJHH330brvthiW/pZRDhgw58sgjX3vtNXwKh2MbzXJ8Gb87plmON98LbgAAIABJREFUL+OXNuO6rllG7p133nnttdfmzJmTy+WUUpZldXZ2Oo5zww03rFq1qqenx3GcAw44QAgxYcKEQqFg0iOkREqpQqGA1C2TyWCU3vsy82Rt28YEc8zMUEqtW7du7733Pvzww4UQZh2+YcOGHXfccW+//TbWYozjePjw4b7vP/3003fffTcKgzGFtm0PHz587NixQohsNtvT0/Puu+8uWLBgyJAhruti3ZaOjo6TTjrpiSeeKJVKiEfXdffZZx+MxtPVJ23UGbcq+jG3cxynXC739PS4rlssFnH9xRQVlABz70X1QUDoV7711ltt2/Y8z/O8H//4x4hV/JVSatddd7311lu/9KUv4SPmzp2L8RyVSqWvry+Xy918880jR450HMe27YsvvrhQKGAQYp0xtphXj+KtWbNm1KhRmLH/jW98Y9iwYUIIDOE0j+Xpr/3T7Jrl+KKNwaquPIlbBWbCo5YWhmE+n0dLD9dQMJrl+DJ+d0yzHF/GL20G8Y6pM1ijJ5PJmNmyOGmVUq+88goqMGecccYvfvELrMv97LPP7rPPPh0dHXfccYdphMbKcFjWZ0sfatYQjuMYE4zMaJAkSQqFAnI+bKFcLg8bNiyO4+7u7nw+XygU8vn8pk2bsOQQilcul5GZhWH44Q9/+CMf+Qjqn1hCBfNChBCYt46lf4QQzzzzjKg+A8Ysm4czX29tYfZ+i400TXO5HNa3HDp0qKgOP0QdDsvVmOQXTw5ZsmTJlClThBBRFD399NOIWzS3ZrNZPDYkm83+5je/0VrfeuutpVIpk8n85je/ufLKKzs6OizL2m233R555BHf93/2s58hK7///vt//OMf1ymnuVL09fXNnDlz7dq12Wz2oosu0lqvX7/+qaeeyufzPT09KBWvHUazHF/M6evu7s7lcphGns/ncYfAo106OzsrlQqm43GendEsx5fxu2Oa5fgyfqmWZVno9MSZ2dHR0dPTg3hHro8cLgzDJ598cs8990Sf5tSpU7XWr7/++rhx44QQvu/Pnz//+eefx0nY2dmJ9VNMw/975fP5vr6+tPowQ7Omt1VdVbtYLGJirBAil8u98sorGzduzOfzpVIJS3yjWbFcLmNhcLwT6R2KhFbzTCbT1dV18MEHr1+/vnYIBBbzO+OMM8yk2mw2a2o7eMUsJP6++u3ah12w22677brrrvfff/+7776LkY9a6w0bNpx44okXXHCB7/t4BCFKv3Dhwn333XfVqlVa63333bdSqQRB0Nvbi2+Ot+GBG2EYfv3rX9dar1u3bvLkyW+99RZSeMR2EATf+c53sMbgUUcd9cYbb9T/zp7nFYvFtWvX3n///T/60Y82bdo0f/58IUQ2m33sscdKpRIqsnUOfBtqluObJIkQYujQob7vp2n60EMPrVmzBjUhpVRXV9ddd9215557dnZ2+r5fuxhSm2uW4ysYvzukWY4v45dqoZqBHAvrGn70ox994oknenp60GaGRRDRhYrhaOi1jKJo9913v+eee7TWN95444oVK5BvhWHY19dXKBTqPx+lUqlglUcM/YyiyCzi+KlPfWrFihVr1qxR1YccBkHQ09OzcuXKXXfd1XEcz/MymQyKt++++44bNw6LmCATdRznueee++Mf/4i2c9u2x44du2jRohdffBG5XRiGURShsRB9x3goS09Pj23baGiP4xiPuK3zFfqz3U5K2dnZeeSRRy5ZsuSiiy6KoghX4blz5z700ENHHHEESonUFRWvlStXPvnkk1prDNT48pe/fPXVV2PBTKXU7bffLqW88sorsaK0EGLdunULFy78m7/5GyHE//7v/2LNJGwzjuPly5cvXbp0l112qb/0uRCiUCj4vq+UWrZsGfpukiS55JJLLrzwwto1Y5K6z2trK81yfHEbQHt1pVJZv379ueee29XVhV6ef/qnf1q8ePFpp52266674hIwYDtwkGuW4wuM3+3VLMeX8Uu10GBmHmr8kY985POf//yCBQu+973vofkqiqKXX3555MiRmFXd29t7wgkn7L///uvXr8fYg2KxuHjx4jFjxgwZMgS1EQzg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bdu1tbXTp09/6623OOedO3d+/vnnQ6EQ+ut33nnnhAkTHMfZunXrJ598smXLlhUrVlRUVNTV1ZmmWVFRsWXLlq+++mr37t2YGX348OG9e/cyz+xFFy2VSqmq+vnnn//Hf/zH4cOHUY8vXboU02YZY2KBBWbcz5o16/nnn3ddF+MIGCNAhw8tEEbHX3vtte7du3POBw4c+OSTT1qW9cQTTwwZMsRxnEsvvXTjxo2Y9osJKOgONmpq5wcnVV+MwKbTadM0W7du/dxzzw0cONC27eHDh8+fPz8ajcLxxjwHEunbYOLxuH8t4fTp09955x3XdTt37rxw4UK0voyxiRMn3nHHHZlMZu/evStXrtywYcOmTZvKy8tN06yrq5MkafPmzZ9++mlZWZllWXV1dVVVVVu3boXjBx4y2O51dXWrV69+5ZVX6urqMpnMNddcs3jxYvjgYWrApGCMlZWVbd68eejQobFYbMiQIZDv4MGDZ5xxBjpsvXr12rFjx549e2pqarp164ZbdOvW7dChQ9FoFLkCI4kY+9uyZQsM/bvvvvupp57inO/cufMvf/nL9u3bv/rqq48//pgxhomDrusWFRUFQHfkYYyzT58+fdasWZZl3XDDDQsWLCgqKoJ9NnfuXMyd+P7773ft2rVmzRrbtn//+9/v2rXLsqxx48atXbu2trb2j3/846ZNmzjn11577erVq1HBYgKD4zjw5kYike+++w7lbvr06TNnzoRPXQxawW/HGNu7d+99991XVFQUDoe//PJL27arqqoikUjbtm0VRWnXrh1MvfLy8i5durRt29YwjC5dupSWlsK7jyFg5s3oNU1z0aJFa9as2bJly0svvbRr1659+/Y99thjX3zxRU1Nzb59+9B1qaurgwmLBAlwn40AmGrCGBsxYsSMGTMWLlw4evTo7du333PPPd99911VVZVlWfPnz89kMgsWLPjuu+9M05wyZcrixYtvvPHGGTNmvPHGG5MnT0a3hHmTTDCqe+GFF37zzTdnnXVWVVUVsnEymcScEwz6o4+0c+dOOLYnT578hz/8IZVKfffdd4sWLfrmm2+WL1++efPmnHcgT/j2cL1s2bKldevW3bt3d1337rvvvummm1AjxGKxp59+evTo0Yyx4uLidu3awWROp9MYnXniiSd69uyJURXM9fm3f/u3kpKSbDYbi8VQX2uaFovFLMu64IILPvnkk8LCQkmS2rVrV1lZKVpl5oVCgB2AQQes+xPDTzgG3lTMN7rssstGjhyZzWavu+66bdu2/fDDD1u2bBk1ahRj7Oc///mFF17IvaAJ6BMj9zQrTra+KCHRaBSDNcOHDx8yZIgsy6NHj968eXNlZSVMOv/sV0b6Ngg0cljiun379sLCwk6dOrmuO23atBtvvBFFiTG2aNGiX/3qV6gr27VrV1BQkEqlTNPE6OpDDz3Up08fjNlls1ld15988smePXsizcUwhGmaBQUFgwcPXrJkSTweD4VCZ5xxBobymS9YBjymqVQqkUhs2LDBNM0rrrhi6tSphmHs3bs3lUrBJwePoyzL27Ztg2MYE5wxHoceAiYJ4O06dOgwcuRIWCcHDx7cvHnzl19+edlll8FYvPXWW8WotKIoNTU1wdAdkxZ27dpVVVV1zjnnmKY5fvz4mTNnVldXo+DMnTv3wQcfdF23uLgYjk/DMNq2bQub+J/+6Z9QNMTikvHjx19xxRVi6oVYosEYy2Qybdq0QcG/8sor4UM1TTORSKCc2rYdjUbr6ur279//5ptv1tTUfPzxx1OmTNm1a1dFRQUm/zEvJ4RCoT179jiOU11dres6qg4swUHziRUYuq5rmjZ+/PhEIlFSUjJ06NDPP//84MGDp59+eq9evVq0aHH99dfjLGSPVCpFVl0zAfkEDQp6j5qmrV+/vm/fvoWFhYWFhWPHjj1w4EAqlUI1xTkfM2bMhAkTMEkDbRPAAkHUY2IqqiRJiUQik8nYth2Px+ELRzbD9OLCwsKrrrrKtu3rr7++qqrq0KFDX3755aBBg/r06aMoyoQJE/LPtkPruH//fsdxkskkBm4YYzB7FUVZuXIliutpp5323XffybJ87rnnXnzxxeFwOBaLYQ71oEGDLrzwwng8ruv6q6++KkZJNE3DumX08tPp9M033wyXzPjx47EOizGG1S4YYUGfHl1/yYvmwLxIM2iBxAq+kpISWI1ok8rLy6uqqkTzg4EePAksSP7jwFrNgZOtLwbFcC/btrt3744pcZhmd8SicTGHhvQ9UTCJCikTDoe3b98uJkhBBSw9CYVCq1evRjt62mmnbdq0yXXdQYMGYYxPVdUXX3yRMXbeeecNGjQoHo9rmvbSSy9hZrGIRYLZJ7DbpkyZghHYG264QQTpwDw/5kUWKCkpefvtt7t168YYGzly5L59+/bv39+jRw/ZC3gBH1tBQUG7du1EIA+RhWzbjsViNTU10NR13ZYtW3bo0AHjhqqq6rp+4MABf/AU1CqoLsQaz7xGDDtWVVXV19djxAPfoIg5joO1KYqi6Lr+7LPPyrJcXFx87733XnfddYqiTJ06NZvNFhYWPv7441dddZUsy7fffjs8c6KQipU0jLGioqLTTjtN8qLVYPIMqguYzo7jFBQU/Od//udVV12ladr5558/ePDgb775JhaLwV3HvP6GbdtdunTh3jJt2JpiRTbzhdSxbfuMM85ATw/DvqWlpagrmDenAr9iITDmXTW1GEST43ix5fwLICRJeuqpp4qLi3Vdv/jii/fs2ROJRObMmTN69GhMLoJpgbNgPyDbiEshl6KiCIVCYiUWJpyIteGWZZ122mlwbaBecl13586dIhxBOBzO+eBAQ9ZSSJLUrVs3x3FatGiBmbyu60aj0UwmU1VVNWfOnHXr1mUymcOHD3fq1AmtyI033pjJZA4cOLBhw4bVq1dLknTjjTeiHH700UcrV65Euw7BkF6maS5btkxVVXRDX375ZURFwVI4sSIGZR7DfIZhFBYWQjzMvcB6W5iMlmWVlpZWVFRgrOrAgQOtW7dOJBIYeIrFYpjxoygKBtf9SzubDydbXyxdRBGKxWLbt2/HetWamprKykrYeYoX2wKGHenbAODcEinZvXt3sXwYurRo0YIxVl5ePm/evHfffRfrK3v37o0yOGbMGM55ZWXlxo0b33vvvVAodMMNN5immUwmP/nkE0gs1sMiGU3TfOuttxhjNTU1mUxm0aJFYgEjYwzJjrMwNirmV3Ts2LG4uDgej1dXV8diMcbYnj17evfu3apVq3bt2u3duzeZTGYymR9++KFr167Mi8pRXFwMO0OW5erq6u+//76goKCiomLfvn2maXbq1EmspkfQPrge/U7fvAaVpOu6bdq0QdLhe8xbsG07m80+9thjM2bMwKyjSZMmwXI688wz169fzzn/xS9+8cgjj9i23bVrVyw3vuCCCzBxVvKihfnjp9TX1+/ZswerkTKZjIieiJ42jqyrq8Nd8DedTrdv3764uDgcDpeVlWGyBxwhLVu2TCaT9fX12Wz2+++/b9u2rewFSGKMwYGHNRM7duyQZbmurg7Bxtq2bQsrEPMrdF1HL0UE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)

##Pré-processamento das imagens para geração dos tensores de imagem
"""

# Pre-processamento das imagens e geração dos lotes dos tensores.

#Tamanho do lote
batch_size = 64 

#Pré-processamento e aumento dos dados para o treinamento
#Tem por objetivo tornar o modelo mais genérico
train_datagen = ImageDataGenerator(rescale=1./255,
                                   zoom_range=0.3,
                                   horizontal_flip=True)

#Tensores de treino
training_set = train_datagen.flow_from_directory(train_dir,
                                                batch_size=batch_size,
                                                target_size=(picture_size,picture_size),
                                                shuffle=True,
                                                color_mode='grayscale',
                                                class_mode='categorical')

#Pré-processamento das imagens de validação.
val_datagen = ImageDataGenerator(rescale=1./255)

#Tensores de validação
val_set = val_datagen.flow_from_directory(val_dir,
                                                batch_size=batch_size,
                                                target_size=(picture_size,picture_size),
                                                shuffle=True,
                                                color_mode='grayscale',
                                                class_mode='categorical')

#Pré-processamento das imagens de teste.
test_datagen = ImageDataGenerator(rescale=1./255)

#Tensores de teste
test_set = test_datagen.flow_from_directory(test_dir,
                                                batch_size=batch_size,
                                                target_size=(picture_size,picture_size),
                                                shuffle=True,
                                                color_mode='grayscale',
                                                class_mode='categorical')

training_set.class_indices

#Verificação dos tensores gerados imprimindo o tensor e a label correspondente.
class_labels=['Desprezo','Felicidade','Medo','Neutro','Nojo','Raiva','Surpresa','Tristeza']
img, label = val_set.__next__()

import random #Usado para selecionar a imagem aleatóriamente

i=random.randint(0, (img.shape[0])-1)
image = img[i]
labl = class_labels[label[i].argmax()]
plt.imshow(image[:,:,0], cmap='gray')
plt.title(labl)
plt.show()

"""##Calculo do tamanho da imagem de saída
*   O = Saída
*   I = Entrada
*   K = Kernel
*   p = Padding
*   S = Stride

O = [(I - K + 2p)/S]+1

##Definindo modelo inicial
"""

#Número de classes (labels)
classes = 8

#Inicializando a arquitetura da rede CNN
model = tf.keras.models.Sequential(name='rede1')

# Primeira camada de convolução   
model.add(Conv2D(64, kernel_size=(5, 5), padding='same', activation='relu', input_shape = (48,48,1))) #Saida 64x48x48
#Camada de pooling
model.add(MaxPooling2D(2, 2))
#Dropout - Ajuda o modelo a não dar overfitting, desativando aleatóriamente e temporariamente, alguns nerônios.
model.add(Dropout(0.25))
#Saida 64x24x24

# Segunda camada de convolução 
model.add(Conv2D(128, kernel_size=(3, 3), activation='relu', padding='same', kernel_regularizer=regularizers.l2(0.01))) #Saida 128x24x24
#Normalização
model.add(BatchNormalization())
#Camada de pooling
model.add(MaxPooling2D(pool_size=(2, 2)))
#Dropout
model.add(Dropout(0.25))
#Saida 128x12x12

# Terceira camada de convolução
model.add(Conv2D(256, kernel_size=(3, 3), activation='relu', kernel_regularizer=regularizers.l2(0.01))) #Saida 256x10x10
#Normalização
model.add(BatchNormalization())
#Camada de pooling
model.add(MaxPooling2D(pool_size=(2, 2)))
#Dropout
model.add(Dropout(0.25))
#Saida 256x5x5

#Criando o vetor. Uma única dimensão.
model.add(Flatten())
#Vetor de 6400 valores (256*5*5)

# Primeira camada densa (Fully Connected)
model.add(Dense(256, activation='relu'))
model.add(Dropout(0.25))
  
# Segunda camada densa (Fully Connected)
model.add(Dense(512, activation='relu')) 
model.add(Dropout(0.25))

# Terceira camada densa - Camada de saída
model.add(Dense(classes, activation='softmax'))

#Compilando o modelo (modo de treinamento).
#ADAM - Gradient Descent (com momentum) => É um gradiente descendente estocástico com estimação adaptativa de momentos de primeira e segunda ordem.
model.compile(optimizer=Adam(learning_rate=0.0001, decay=1e-6), loss='categorical_crossentropy', metrics=['accuracy'])

#Imprimindo sumário da arquitetura da rede
modelo1=model
modelo1.summary()

"""###Função Callbacks - Rede 1"""

chk_path = 'rede1.h5'

log_dir = "checkpoint/logs/" + datetime.datetime.now().strftime("%Y%m%d-%H%M%S")

#Salva o modelo.
checkpoint = ModelCheckpoint(filepath=chk_path,
                             save_best_only=True,
                             verbose=1,
                             mode='min',
                             moniter='val_loss')

#Para o treinamento quando a metrica monitorada para de melhorar.
earlystop = EarlyStopping(monitor='val_loss', 
                          min_delta=0, 
                          patience=3, 
                          verbose=1, 
                          restore_best_weights=True)

#Reduz a taxa de aprendizado quando a metrica monitorada para de melhorar.                        
reduce_lr = ReduceLROnPlateau(monitor='val_loss', 
                              factor=0.2, 
                              patience=6, 
                              verbose=1, 
                              min_delta=0.0001)


tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_dir, histogram_freq=1)
csv_logger = CSVLogger('training1.csv', separator= ",", append=True)

callbacks = [checkpoint, reduce_lr, csv_logger]

"""###Passando os dados de treinamento e validação no modelo


"""

steps_per_epoch = training_set.n // training_set.batch_size #32645//64 = 510 passos por época
validation_steps = val_set.n // val_set.batch_size #8086//64 = 126

history = model.fit(x=training_set,
                 validation_data=val_set,
                 epochs=60,
                 callbacks=callbacks,
                 steps_per_epoch=steps_per_epoch,
                 validation_steps=validation_steps)

"""###Salvando o modelo"""

#Salvando o modelo para uso futuro
model.save('/content/drive/MyDrive/Projeto_II/Detector_de_expressoes/modelo1.h5')

"""###Analisando o resultado do modelo"""

#Imprimindo gráfico da performance da rede em relação a acurácia
plt.figure(figsize=(14,5))
plt.subplot(1,2,2)
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('Acurácia do Modelo 1')
plt.xlabel('Epoca')
plt.ylabel('Acurácia')
plt.legend(['Treino', 'Validação'], loc='upper left')

#Imprimindo gráfico da performance da rede em relação a perda
plt.subplot(1,2,1)
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Perda do Modelo 1')
plt.xlabel('Epoca')
plt.ylabel('Perda')
plt.legend(['Treino', 'Validação'], loc='upper left')
plt.show()

"""###Observação sobre o resultado:

O conjunto de treinamento e validação tiveram acurácia semelhante, entorno de 68%. Não apresentou overfitting, podendo-se concluir que a ineficiência pode ser devido a pouca profundidade da rede e/ou pela própria característica do dataset.

##Definindo o segundo modelo
Criando uma rede mais profunda
"""

#Número de classes (labels)
classes = 8

#Inicializando a segunda arquitetura de rede CNN
model = tf.keras.models.Sequential(name='rede2')

# Primeira camada de convolução   
model.add(Conv2D(32, kernel_size=(3, 3), padding='same', activation='relu', input_shape = (48,48,1))) #Saida 32x48x48
# Segunda camada de convolução 
model.add(Conv2D(64, kernel_size=(3, 3), padding='same', activation='relu')) #Saida 64x48x48
# Normalização 
model.add(BatchNormalization())
# Camada de pooling
model.add(MaxPooling2D(2, 2))
#Dropout
model.add(Dropout(0.25))
#Saida 64x24x24


# Terceira camada de convolução 
model.add(Conv2D(128, kernel_size=(3, 3), activation='relu', padding='same', kernel_regularizer=regularizers.l2(0.01))) #Saida 128x24x24
# Quarta camada de convolução 
model.add(Conv2D(256, kernel_size=(3, 3), activation='relu', kernel_regularizer=regularizers.l2(0.01))) #Saida 256x24x24
# Normalização 
model.add(BatchNormalization())
# Camada de pooling
model.add(MaxPooling2D(pool_size=(2, 2)))
#Dropout
model.add(Dropout(0.25))
#Saida 256x11x11


# Quinta camada de convolução 
model.add(Conv2D(512, kernel_size=(3, 3), activation='relu', padding='same', kernel_regularizer=regularizers.l2(0.01))) #Saida 512x11x11
# Normalização 
model.add(BatchNormalization())
# Camada de pooling
model.add(MaxPooling2D(pool_size=(2, 2)))
#Dropout
model.add(Dropout(0.25))
#Saida 512x5x5

#Criando o vetor. Uma única dimensão.
model.add(Flatten())
#Vetor de 12800 valores (512*5*5)

# Primeira camada densa (Fully Connected)
model.add(Dense(512, activation='relu'))
#Dropout
model.add(Dropout(0.5))

# Segunda camada densa (Fully Connected)
model.add(Dense(1024, activation='relu'))
#Dropout
model.add(Dropout(0.5))

# Terceira camada densa - Camada de Saída
model.add(Dense(classes, activation='softmax'))

#Compilando o modelo
model.compile(optimizer=Adam(learning_rate=0.0001, decay=1e-6), loss='categorical_crossentropy', metrics=['accuracy'])

#Imprimindo sumário da arquitetura da rede
modelo2=model
modelo2.summary()

"""###Função Callbacks - Rede 2"""

chk_path = 'modelo2.h5'
log_dir = "checkpoint/logs/" + datetime.datetime.now().strftime("%Y%m%d-%H%M%S")

#Salva o modelo.
checkpoint = ModelCheckpoint(filepath=chk_path,
                             save_best_only=True,
                             verbose=1,
                             mode='min',
                             moniter='val_loss')

#Para o treinamento quando a metrica monitorada para de melhorar.
earlystop = EarlyStopping(monitor='val_loss', 
                          min_delta=0, 
                          patience=3, 
                          verbose=1, 
                          restore_best_weights=True)

#Reduz a taxa de aprendizado quando a metrica monitorada para de melhorar.                          
reduce_lr = ReduceLROnPlateau(monitor='val_loss', 
                              factor=0.2, 
                              patience=6, 
                              verbose=1, 
                              min_delta=0.0001)


tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_dir, histogram_freq=1)
csv_logger = CSVLogger('training2.log')

callbacks = [checkpoint, reduce_lr, csv_logger]

"""###Passando os dados de treinamento e validação no modelo"""

steps_per_epoch = training_set.n // training_set.batch_size
validation_steps = val_set.n // val_set.batch_size

history = modelo2.fit(x=training_set,
                 validation_data=val_set,
                 epochs=60,
                 callbacks=callbacks,
                 steps_per_epoch=steps_per_epoch,
                 validation_steps=validation_steps)

"""###Salvando o modelo"""

#Salvando o modelo
model.save('/content/drive/MyDrive/Projeto_II/Detector_de_expressoes/modelo2.h5')

"""###Analisando o resultado do modelo"""

#Imprimindo gráfico da performance da rede em relação a acurácia
plt.figure(figsize=(14,5))
plt.subplot(1,2,2)
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('Acurácia do Modelo 2')
plt.xlabel('Epoca')
plt.ylabel('Acurácia')
plt.legend(['Treino', 'Validação'], loc='upper left')

#Imprimindo gráfico da performance da rede em relação a perda
plt.subplot(1,2,1)
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Perda do Modelo 2')
plt.xlabel('Epoca')
plt.ylabel('Perda')
plt.legend(['Treino', 'Validação'], loc='upper left')
plt.show()

"""###Verificando a acurácia"""

train_loss, train_accu = modelo2.evaluate(training_set)
val_loss, val_accu = modelo2.evaluate(val_set)
print("Acurácia final no treinamento = {:.2f} , Acurácia na validação = {:.2f}".format(train_accu*100, val_accu*100))

"""###Matriz de Confusão"""

#Matriz de confusão dos dados de treino
y_pred = modelo2.predict(training_set)
y_pred = np.argmax(y_pred, axis=1)
class_labels = test_set.class_indices
class_labels = {v:k for k,v in class_labels.items()}

from sklearn.metrics import classification_report, confusion_matrix
cm_train = confusion_matrix(training_set.classes, y_pred)
print('Matrix de Confusão')
print(cm_train)
print('Relatório da Classificação')
target_names = list(class_labels.values())
print(classification_report(training_set.classes, y_pred, target_names=target_names))

plt.figure(figsize=(8,8))
plt.imshow(cm_train, interpolation='nearest')
plt.colorbar()
tick_mark = np.arange(len(target_names))
_ = plt.xticks(tick_mark, target_names, rotation=90)
_ = plt.yticks(tick_mark, target_names)

#Matriz de confusão dos dados de validação
y_pred = modelo2.predict(val_set)
y_pred = np.argmax(y_pred, axis=1)
class_labels = val_set.class_indices
class_labels = {v:k for k,v in class_labels.items()}

#from sklearn.metrics import classification_report, confusion_matrix
cm_val = confusion_matrix(val_set.classes, y_pred)
print('Matriz de Confusão')
print(cm_val)
print('Relatório da Classificação')
target_names = list(class_labels.values())
print(classification_report(val_set.classes, y_pred, target_names=target_names))

plt.figure(figsize=(8,8))
plt.imshow(cm_val, interpolation='nearest')
plt.colorbar()
tick_mark = np.arange(len(target_names))
_ = plt.xticks(tick_mark, target_names, rotation=90)
_ = plt.yticks(tick_mark, target_names)

"""###Observação sobre o resultado:

A acurácia aumenta pouco no conjunto de treinamento, mas no de validação fica no máximo em 68%. Não apresenta indicação de overfitting. Pode-se inferir que a baixa acurácia pode estar relacionada ao conjunto de dados desbalanceado. Observa-se na matriz de confusão e no relatório de classificação, que tanto nos dados de treino quando nos de validação, os maiores erros ocorreram na classificação das features "desprezo" e "nojo". O menor erro foi na classificação da feature "felicidade".

##Definindo o terceiro modelo
Utilizando Transfer Learning

Neste modelo utilizou-se a arquitetura de rede VGG16, que é uma rede de aprendizado profundo, apresentando 13 camadas de convolução e camadas 3 densas. Desenvolvida por Karen Simonyan e Andrew Zisserman. Desenvolveram o modelo baseado na ideia do ImageNet Challenge 2014.

O ImageNet Large Scale Visual Recognition Challenge (ILSVRC) avalia algoritmos para detecção de objetos e classificação de imagens em grande escala. A ideia é permitir que pesquisadores comparem o progresso na detecção de uma grande variedade de objetos e medir o progresso da visão computacional para indexação de imagens em larga escala. Banco de dados com mais de 14 milhões de imagens em mais de 20.000 classes.
"""

#Carregando modelo pré-processado
vgg_model = tf.keras.applications.vgg16.VGG16()
print(type(vgg_model))

#Visualizando a arquitetura da rede
vgg_model.summary()

#Removendo a última camada da rede
model = tf.keras.models.Sequential(name='rede3')
for layer in vgg_model.layers[0:-1]:
  model.add(layer)
model.summary()

#Tornando todas as camadas "não treináveis"
for layer in model.layers:
  layer.trainable = False
model.summary()

classes = 8
#Adicionando a ultima camada
model.add(Dense(classes, activation='softmax'))

#Arquitetura final da rede
modelo3 = model
modelo3.summary()

#Compilando o modelo
modelo3.compile(optimizer=Adam(learning_rate=0.0001, decay=1e-6), loss='categorical_crossentropy', metrics=['accuracy'])

preprocess_input = tf.keras.applications.vgg16.preprocess_input

batch_size = 64
picture_size = 244
#Gerar lotes de tensor de imagens com Augmentation, usando o pre processamento da VGG16
train_gen = tf.keras.preprocessing.image.ImageDataGenerator(preprocessing_function=preprocess_input)
valid_gen = tf.keras.preprocessing.image.ImageDataGenerator(preprocessing_function=preprocess_input)
test_gen = tf.keras.preprocessing.image.ImageDataGenerator(preprocessing_function=preprocess_input)

#Tensores de treino
training_batches = train_gen.flow_from_directory(train_dir,
                                                batch_size=batch_size,
                                                target_size=(picture_size,picture_size),
                                                shuffle=True,
                                                color_mode='rgb',
                                                class_mode='categorical')
#Tensores de validação
val_batches = valid_gen.flow_from_directory(val_dir,
                                                batch_size=batch_size,
                                                target_size=(picture_size,picture_size),
                                                shuffle=True,
                                                color_mode='rgb',
                                                class_mode='categorical')
#Tensores de teste
test_batches = test_gen.flow_from_directory(test_dir,
                                                batch_size=batch_size,
                                                target_size=(picture_size,picture_size),
                                                shuffle=True,
                                                color_mode='rgb',
                                                class_mode='categorical')

"""###Função Callbacks - Rede 3"""

chk_path = 'modelo3.h5'
log_dir = "checkpoint/logs/" + datetime.datetime.now().strftime("%Y%m%d-%H%M%S")

#Salva o modelo.
checkpoint = ModelCheckpoint(filepath=chk_path,
                             save_best_only=True,
                             verbose=1,
                             mode='min',
                             moniter='val_loss')

#Para o treinamento quando a metrica monitorada para de melhorar.
earlystop = EarlyStopping(monitor='val_loss', 
                          min_delta=0, 
                          patience=5, 
                          verbose=1, 
                          restore_best_weights=True)

#Reduz a taxa de aprendizado quando a metrica monitorada para de melhorar.                          
reduce_lr = ReduceLROnPlateau(monitor='val_loss', 
                              factor=0.2, 
                              patience=6, 
                              verbose=1, 
                              min_delta=0.0001)


tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_dir, histogram_freq=1)
csv_logger = CSVLogger('training3.log')

callbacks = [checkpoint, reduce_lr, csv_logger]

"""###Passando os dados de treinamento e validação no modelo"""

steps_per_epoch = training_batches.n // training_batches.batch_size
validation_steps = val_batches.n // val_batches.batch_size

history = modelo3.fit(x=training_batches,
                 validation_data=val_batches,
                 epochs=20,
                 callbacks=callbacks,
                 steps_per_epoch=steps_per_epoch,
                 validation_steps=validation_steps)

#Salvando o modelo
modelo3.save('/content/drive/MyDrive/Projeto_II/Detector_de_expressoes/modelo3.h5')

"""###Analisando o resultado do modelo"""

#Imprimindo gráfico da performance da rede em relação a acurácia
plt.figure(figsize=(14,5))
plt.subplot(1,2,2)
plt.plot(history.history['accuracy'])
plt.plot(history.history['val_accuracy'])
plt.title('Acurácia do Modelo 3')
plt.xlabel('Epoca')
plt.ylabel('Acurácia')
plt.legend(['Treino', 'Validação'], loc='upper left')

#Imprimindo gráfico da performance da rede em relação a perda
plt.subplot(1,2,1)
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Perda do Modelo 3')
plt.xlabel('Epoca')
plt.ylabel('Perda')
plt.legend(['Treino', 'Validação'], loc='upper left')
plt.show()

"""###Verificando a acurácia"""

train_loss, train_accu = modelo3.evaluate(training_batches)
val_loss, val_accu = modelo3.evaluate(val_batches)
print("Acurácia final no treinamento = {:.2f} , Acurácia na validação = {:.2f}".format(train_accu*100, val_accu*100))

"""###Matriz de Confusão"""

#Matriz de confusão dos dados de treino
y_pred = modelo3.predict(training_batches)
y_pred = np.argmax(y_pred, axis=1)
class_labels = test_batches.class_indices
class_labels = {v:k for k,v in class_labels.items()}

from sklearn.metrics import classification_report, confusion_matrix
cm_train = confusion_matrix(training_batches.classes, y_pred)
print('Matrix de Confusão')
print(cm_train)
print('Relatório da Classificação')
target_names = list(class_labels.values())
print(classification_report(training_batches.classes, y_pred, target_names=target_names))

plt.figure(figsize=(8,8))
plt.imshow(cm_train, interpolation='nearest')
plt.colorbar()
tick_mark = np.arange(len(target_names))
_ = plt.xticks(tick_mark, target_names, rotation=90)
_ = plt.yticks(tick_mark, target_names)

"""###Observação sobre o resultado:

Observando o gráfico, fica claro o sinal de underfitting. Como o modelo foi treinado em apenas 20 épocas, não foi suficiente para alcançar o melhor resultado com o treinamento. Comparando a acurácia na época 20, com os demais modelos, a acurácia ficou semelhante, entorno de 55%. O custo computacional foi muito elevado para rodar o modelo, o que inviabilizou treina-lo por mais épocas. Contudo, pelo fato do desempenho na função de custo e acurácia ser semelhante entre os outros modelos na 20° época, acredita-se que a performance desta rede não seria melhor que nas outras duas.

Nota-se na matriz de confusão, que a maior dificuldade continua sendo na separação da classe "nojo" e "desprezo". Isso pode indicar a necessidade de mais exemplos destas classes para o treinamento.

#Etapa III

##Aplicando o modelo para predição
Como os três modelos apresentaram desempenhos semelhantes, optou-se por utilizar o segundo modelo para realizar a predição, usando os dados de teste.

###Importando a biblioteca
"""

#Importando a biblioteca para carregar o modelo
from keras.models import load_model

"""###Carregando o modelo"""

#Carregando o modelo
#Compile=False pois não se deseja treinar o modelo com os dados de teste.
my_model = load_model('/content/drive/MyDrive/Projeto_II/Detector_de_expressoes/modelo2.h5', compile=False)

#Criando os lotes de imagens
test_img, test_lbl = test_set.__next__()
predictions=my_model.predict(test_img)

predictions = np.argmax(predictions, axis=1)
test_labels = np.argmax(test_lbl, axis=1)

from sklearn import metrics #Importando o método metrics para verificar a acurácia do modelo no dataset de teste
print ("Acurácia = ", metrics.accuracy_score(test_labels, predictions))

#Matrix de Confusão do lote
#from sklearn.metrics import confusion_matrix
import seaborn as sns
cm = confusion_matrix(test_labels, predictions)
sns.heatmap(cm, annot=True)
#print(cm)

"""##Fazendo predição"""

#import random
#class_labels=['Desprezo','Felicidade','Medo','Neutro','Nojo','Raiva','Surpresa','Tristeza']
#Verificando o resultado de algumas imagens
n=random.randint(0, test_img.shape[0] - 1)
image = test_img[n]
orig_labl = class_labels[test_labels[n]]
pred_labl = class_labels[predictions[n]]
plt.imshow(image[:,:,0], cmap='gray')
plt.title("Original label is:"+orig_labl+" Predicted is: "+ pred_labl)
plt.show()

n=random.randint(0, test_img.shape[0] - 1)
image = test_img[n]
orig_labl = class_labels[test_labels[n]]
pred_labl = class_labels[predictions[n]]
plt.imshow(image[:,:,0], cmap='gray')
plt.title("Original label is:"+orig_labl+" Predicted is: "+ pred_labl)
plt.show()

n=random.randint(0, test_img.shape[0] - 1)
image = test_img[n]
orig_labl = class_labels[test_labels[n]]
pred_labl = class_labels[predictions[n]]
plt.imshow(image[:,:,0], cmap='gray')
plt.title("Original label is:"+orig_labl+" Predicted is: "+ pred_labl)
plt.show()

n=random.randint(0, test_img.shape[0] - 1)
image = test_img[n]
orig_labl = class_labels[test_labels[n]]
pred_labl = class_labels[predictions[n]]
plt.imshow(image[:,:,0], cmap='gray')
plt.title("Original label is:"+orig_labl+" Predicted is: "+ pred_labl)
plt.show()

"""##Conclusão

Todas as etapas previstas na disciplina Projetos II foram desenvolvidas e descritas neste notebook.

O objetivo de criar um modelo para reconhecer as expressões das faces das pessoas foi alcançado, atingindo acurácia de 68%.

O aumento da profundidade da rede não provocou a melhora no modelo. Notou-se a dificuldade do modelo em distinguir as classes desprezo e nojo, devido suas semelhanças e, provavelmente, por haver menos exemplos no dataset e consequentemente, menor número de exemplos para o treinamento da rede. Sugere-se aumentar o número de exemplos destas classes e produzir um dataset mais balanceado, para testar os modelos aqui apresentados.

Outros ajustes podem ser feitos para aprimorar os modelos apresentados, como por exemplo: utilizar outras técnicas de Data Augmentation; utilizar Transfer Learning de outra arquitetura, incorporando outro modelo mais treinado na arquitetura da rede ou simplesmente aumentar o número de épocas.
"""